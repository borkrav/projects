#version 460
#extension GL_NV_ray_tracing : require

#include "rng.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;

layout(binding=2, set = 0) uniform CameraProperties
{
    mat4 model;
    mat4 view;
    mat4 proj;
    mat4 modelIT;
    mat4 viewInverse;
    mat4 projInverse;
	uint iteration;
} cam;


struct payload {
	vec3 hitValue;
	vec3 origin;
	vec3 direction;
	bool hit;
	uint seed;
}; 


layout(location = 0) rayPayloadNV payload pl;

layout(binding = 8) buffer accumulationData{ vec4 [] acc; };


uint maxPathLength = 3;
bool accumulate = true;


void main() 
{
    

	//initial ray information
    vec4 origin = cam.viewInverse*vec4(0,0,0,1);

	uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

	vec3 finalColor = vec3(0,0,0);


	uint index = gl_LaunchIDNV.y*gl_LaunchSizeNV.x + gl_LaunchIDNV.x;

	//initialize RNG state, all rays will start with this seed
	rng_state = wang_hash(index * uint(cam.iteration));
	pl.seed = rng_state;


		
	//ensure every iteration has different pixel centre, in order to converge on smooth image
	float offset1 = float(rand_xorshift()) * (1.0 / 4294967296.0);
	float offset2 = float(rand_xorshift()) * (1.0 / 4294967296.0);


	const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(offset1, offset2);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
	vec2 d = inUV * 2.0 - 1.0;
	vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;


	//trace rays
	traceNV(topLevelAS, rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/,
	0 /*missIndex*/, origin.xyz, tmin, direction.xyz, tmax, 0 /*payload*/);

	finalColor += pl.hitValue;

	//keep tracing up to max path length
	for (int i = 0; i < maxPathLength; i++){
		if (pl.hit == true){

			traceNV(topLevelAS, rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/,
			0 /*missIndex*/, pl.origin.xyz, tmin, pl.direction.xyz, tmax, 0 /*payload*/);

			finalColor *= pl.hitValue;
		}
	}
		


	//for first iteration, zero out accumulation buffer
	if (cam.iteration == 1){
		acc[index] = vec4(0);
	}


	if (accumulate){
		acc[index].xyz += finalColor;
	}


	//write results to frame buffer
	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(accumulate ? acc[index].xyz / cam.iteration : finalColor , 0.0));


	
}