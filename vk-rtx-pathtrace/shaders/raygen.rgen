#version 460
#extension GL_NV_ray_tracing : require

#include "rng.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureNV topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D image;

layout(binding=2, set = 0) uniform CameraProperties
{
    mat4 model;
    mat4 view;
    mat4 proj;
    mat4 modelIT;
    mat4 viewInverse;
    mat4 projInverse;
	uint iteration;
} cam;


struct payload {
	vec3 hitValue;
	vec3 origin;
	vec3 direction;
	bool hit;
	uint seed;
}; 


layout(location = 0) rayPayloadNV payload pl;

layout(binding = 8) buffer accumulationData{ vec4 [] acc; }a;

//RNG code taken from here
//http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/

//will probably need to generate some RNG on the CPU and use a buffer
//probably not good enough for the monte-carlo path trace simulation



void main() 
{
    

    vec4 origin = cam.viewInverse*vec4(0,0,0,1);


	uint rayFlags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;

	vec3 finalColor = vec3(0,0,0);

	uint index = gl_LaunchIDNV.y*gl_LaunchSizeNV.x + gl_LaunchIDNV.x;

	rng_state = wang_hash(index * uint(cam.iteration));
	pl.seed = rng_state;




	
	//simple anti-aliasing, 4 rays per pixel
	for (int i = 0; i < 4; i++){

		vec3 iterationColor = vec3(0);
		
		float offset1 = float(rand_xorshift()) * (1.0 / 4294967296.0);
		float offset2 = float(rand_xorshift()) * (1.0 / 4294967296.0);


		const vec2 pixelCenter = vec2(gl_LaunchIDNV.xy) + vec2(offset1, offset2);
		const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeNV.xy);
		vec2 d = inUV * 2.0 - 1.0;
		vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;
		vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;


		traceNV(topLevelAS, rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/,
		0 /*missIndex*/, origin.xyz, tmin, direction.xyz, tmax, 0 /*payload*/);

		iterationColor += pl.hitValue;

		for (int i = 0; i < 3; i++){
			if (pl.hit == true){

				traceNV(topLevelAS, rayFlags, cullMask, 0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/,
				0 /*missIndex*/, pl.origin.xyz, tmin, pl.direction.xyz, tmax, 0 /*payload*/);

				iterationColor *= pl.hitValue;

			}
		}


		finalColor += iterationColor;
		

	}

	finalColor = finalColor/4;

	if (cam.iteration == 1){
		a.acc[index] = vec4(0);
	}

	bool accumulate = true;

	if (accumulate){
		a.acc[index].xyz += finalColor;
	}


	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(accumulate ? a.acc[index].xyz / cam.iteration : finalColor , 0.0));

	


	
}